$date
	Fri Oct 28 15:57:01 2022
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module TestBench $end
$var reg 1 ! Clk $end
$var reg 1 " Reset $end
$var reg 1 # Start $end
$var integer 32 $ counter [31:0] $end
$var integer 32 % i [31:0] $end
$var integer 32 & outfile [31:0] $end
$scope module CPU $end
$var wire 1 ! clk_i $end
$var wire 32 ' pc_i [31:0] $end
$var wire 32 ( pc_o [31:0] $end
$var wire 1 " rst_i $end
$var wire 1 # start_i $end
$var wire 32 ) instr [31:0] $end
$var wire 32 * SignExt_to_Mux [31:0] $end
$var wire 1 + RegWrite $end
$var wire 32 , Read2_to_Mux [31:0] $end
$var wire 32 - Read1_to_ALU [31:0] $end
$var wire 32 . ALU_to_Reg [31:0] $end
$var wire 32 / ALUSrc_Mux_to_ALU [31:0] $end
$var wire 1 0 ALUSrc $end
$var wire 2 1 ALUOp_to_ALUCtrl [1:0] $end
$var wire 3 2 ALUCtrl_to_ALU [2:0] $end
$var reg 1 3 state_r $end
$var reg 1 4 state_w $end
$scope module ALU $end
$var wire 32 5 data_o [31:0] $end
$var wire 32 6 data2_i [31:0] $end
$var wire 32 7 data1_i [31:0] $end
$var wire 1 8 Zero_o $end
$var wire 3 9 ALUCtrl_i [2:0] $end
$var reg 32 : data [31:0] $end
$upscope $end
$scope module ALU_Control $end
$var wire 10 ; funct_i [9:0] $end
$var wire 2 < ALUOp_i [1:0] $end
$var wire 3 = ALUCtrl_o [2:0] $end
$var reg 1 > ALUCtrl $end
$upscope $end
$scope module Add_PC $end
$var wire 32 ? data1_in [31:0] $end
$var wire 32 @ data2_in [31:0] $end
$var wire 32 A data_o [31:0] $end
$upscope $end
$scope module Control $end
$var wire 2 B ALUOp_o [1:0] $end
$var wire 1 0 ALUSrc_o $end
$var wire 7 C Op_i [6:0] $end
$var wire 1 + RegWrite_o $end
$var reg 2 D ALUOp [1:0] $end
$var reg 1 0 ALUSrc $end
$var reg 1 E RegWrite $end
$upscope $end
$scope module Instruction_Memory $end
$var wire 32 F addr_i [31:0] $end
$var wire 32 G instr_o [31:0] $end
$upscope $end
$scope module MUX_ALUSrc $end
$var wire 1 0 select_i $end
$var wire 32 H data_o [31:0] $end
$var wire 32 I data2_i [31:0] $end
$var wire 32 J data1_i [31:0] $end
$upscope $end
$scope module PC $end
$var wire 1 ! clk_i $end
$var wire 32 K pc_i [31:0] $end
$var wire 1 " rst_i $end
$var wire 1 # start_i $end
$var reg 32 L pc_o [31:0] $end
$upscope $end
$scope module Registers $end
$var wire 5 M RDaddr_i [4:0] $end
$var wire 32 N RDdata_i [31:0] $end
$var wire 5 O RS1addr_i [4:0] $end
$var wire 32 P RS1data_o [31:0] $end
$var wire 5 Q RS2addr_i [4:0] $end
$var wire 32 R RS2data_o [31:0] $end
$var wire 1 + RegWrite_i $end
$var wire 1 ! clk_i $end
$upscope $end
$scope module Sign_Extend $end
$var wire 12 S data_i [11:0] $end
$var wire 32 T data_o [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
bx T
bx S
bx R
bx Q
bx P
bx O
bx N
bx M
b0 L
bz K
bx J
bx I
bx H
bx G
bx F
xE
bx D
bx C
bx B
bx A
b100 @
bz ?
x>
b0x =
bx <
bx ;
bx :
b0x 9
x8
bx 7
bx 6
bx 5
x4
x3
b0x 2
bx 1
x0
bx /
bx .
bx -
bx ,
x+
bx *
bx )
bx (
bz '
b11 &
b100000 %
b0 $
0#
0"
0!
$end
#12
14
03
1#
1"
#25
bz L
b1 $
1!
#50
0!
#75
b10 $
1!
#100
0!
#125
b11 $
1!
#150
0!
#175
b100 $
1!
#200
0!
#225
b101 $
1!
#250
0!
#275
b110 $
1!
#300
0!
#325
b111 $
1!
#350
0!
#375
b1000 $
1!
#400
0!
#425
b1001 $
1!
#450
0!
#475
b1010 $
1!
#500
0!
#525
b1011 $
1!
#550
0!
#575
b1100 $
1!
#600
0!
#625
b1101 $
1!
#650
0!
#675
b1110 $
1!
#700
0!
#725
b1111 $
1!
#750
0!
#775
b10000 $
1!
#800
0!
#825
b10001 $
1!
#850
0!
#875
b10010 $
1!
#900
0!
#925
b10011 $
1!
#950
0!
#975
b10100 $
1!
#1000
0!
#1025
b10101 $
1!
#1050
0!
#1075
b10110 $
1!
#1100
0!
#1125
b10111 $
1!
#1150
0!
#1175
b11000 $
1!
#1200
0!
#1225
b11001 $
1!
#1250
0!
#1275
b11010 $
1!
#1300
0!
#1325
b11011 $
1!
#1350
0!
#1375
b11100 $
1!
#1400
0!
#1425
b11101 $
1!
#1450
0!
#1475
b11110 $
1!
#1500
0!
#1525
1!
